---
phase: 03-polish-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/features/simulator/hooks/PATTERNS.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Developer can understand orchestrator data flow by reading PATTERNS.md"
    - "Critical callback wiring is documented with code examples"
    - "Lessons learned from Phase 1/2 are captured for future reference"
  artifacts:
    - path: "app/features/simulator/hooks/PATTERNS.md"
      provides: "Orchestrator effect chain documentation with data flow diagram"
      contains: "Effect Chain Sequence"
  key_links:
    - from: "PATTERNS.md"
      to: "useAutoplayOrchestrator.ts"
      via: "documented callback patterns"
      pattern: "onPromptsReady"
---

<objective>
Update PATTERNS.md with comprehensive orchestrator documentation including data flow diagram and lessons learned from v1.2 milestone.

Purpose: Fulfill ARCH-01, ARCH-02, ARCH-03 requirements - ensure the orchestrator architecture is documented for future maintenance and onboarding.

Output: Updated PATTERNS.md with:
- ASCII data flow diagram of effect chain
- Critical callback wiring table
- Lessons learned section from Phase 1/2 implementation
</objective>

<execution_context>
@C:\Users\mkdol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mkdol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-polish-docs/03-RESEARCH.md

# Source files for documentation
@app/features/simulator/hooks/PATTERNS.md
@app/features/simulator/hooks/useAutoplayOrchestrator.ts
@app/features/simulator/hooks/useMultiPhaseAutoplay.ts
@app/features/simulator/hooks/useAutoplay.ts

# Prior phase summaries with lessons learned
@.planning/phases/01-orchestration-fix/01-01-SUMMARY.md
@.planning/phases/01-orchestration-fix/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add orchestrator data flow diagram and critical callback documentation</name>
  <files>app/features/simulator/hooks/PATTERNS.md</files>
  <action>
Update PATTERNS.md to add a new section "## Autoplay Orchestrator Deep Dive" after the existing orchestrator pattern section. Include:

1. **Architecture Overview** - ASCII diagram showing the three-layer structure:
   ```
   SimulatorContext (Root Coordinator)
           |
           v
   useMultiPhaseAutoplay (Multi-Phase State + Orchestration)
           |
           +--> useAutoplayOrchestrator (Single-Phase Effects)
           |           |
           |           +--> useAutoplay (State Machine)
           |
           +--> useAutoHudGeneration (HUD Phase)
           +--> posterEvaluator (Poster Phase)
   ```

2. **Effect Chain Sequence** - Numbered ASCII flow (based on RESEARCH.md appendix):
   - User clicks Start -> multiPhaseAutoplay.onStart
   - Phase dispatch -> useEffect detects phase change
   - Calls singlePhaseOrchestrator.startAutoplay()
   - useAutoplay sets status='generating'
   - useAutoplayOrchestrator effect detects status
   - Calls onRegeneratePrompts with onPromptsReady callback
   - Callback fires -> generateImagesFromPrompts
   - Continue through evaluate, polish, refine cycle
   - Loop or complete

3. **Critical Callback Wiring Table** - Document the 5 critical callbacks:
   | Callback | Source | Purpose | Critical |
   |----------|--------|---------|----------|
   | onRegeneratePrompts | SimulatorContext | Triggers prompt + image generation | YES |
   | saveImageToPanel | useImageGeneration | Saves approved images | YES |
   | setFeedback | useBrain | Applies refinement feedback | YES |
   | generateImagesFromPrompts | useImageGeneration | Direct image generation | YES |
   | onLogEvent | Optional | Activity logging | NO |

4. **Key Wiring Pattern** - Code example of the onPromptsReady pattern:
   ```typescript
   // Avoid React state timing issues by using callback
   onRegeneratePrompts({
     feedback: feedbackOverride || undefined,
     onPromptsReady: (newPrompts) => {
       // Immediately use fresh prompts, don't wait for state
       generateImagesFromPrompts(newPrompts.map(p => ({ id: p.id, prompt: p.prompt })));
     },
   });
   ```
  </action>
  <verify>
    - PATTERNS.md contains "## Autoplay Orchestrator Deep Dive" section
    - Contains ASCII architecture diagram
    - Contains "Effect Chain Sequence" with numbered steps
    - Contains "Critical Callback Wiring" table with 5 callbacks
    - Contains code example for onPromptsReady pattern
  </verify>
  <done>Orchestrator data flow is documented with diagram and callback table (ARCH-01, ARCH-02)</done>
</task>

<task type="auto">
  <name>Task 2: Add lessons learned section from v1.2 implementation</name>
  <files>app/features/simulator/hooks/PATTERNS.md</files>
  <action>
Add a new section "## Lessons Learned (v1.2 Autoplay)" at the end of PATTERNS.md. Include:

1. **Lesson 1: Callback Over Effect for Async Chains**
   - Problem: Effect-based state watching caused timing issues due to React batching
   - Solution: Pass callbacks (onPromptsReady) to get fresh data synchronously
   - Code pattern: Show the callback approach vs effect approach
   - When to apply: Any time you need immediate access to freshly-computed state

2. **Lesson 2: Delegation Pattern for Multi-Level Orchestration**
   - Problem: Multi-phase autoplay duplicated single-phase logic
   - Solution: Multi-phase instantiates and controls single-phase orchestrator
   - Benefit: Single-phase logic tested once, multi-phase just manages transitions
   - Key insight: Watch isRunning + completionReason for orchestrator state

3. **Lesson 3: Refs for Values in Effects**
   - Problem: State values in effects are stale due to closure semantics
   - Solution: Use refs (generatedPromptsRef, pendingFeedbackRef) for effect-accessed values
   - Warning signs: State values that seem "one step behind"
   - Pattern: Update ref in same render cycle as state update

4. **Lesson 4: Generous Timeouts for AI Services**
   - Problem: 60s timeout was too aggressive for slow AI providers
   - Solution: 120s timeout as safety net, not primary control
   - Principle: Timeouts prevent hangs, not control flow

5. **Common Pitfalls** section:
   - Stale closures in effects (use refs)
   - Relying on state updates for chain propagation (use callbacks)
   - Tight timeouts for external services (use generous safety nets)
  </action>
  <verify>
    - PATTERNS.md contains "## Lessons Learned (v1.2 Autoplay)" section
    - Contains 4 numbered lessons with problem/solution format
    - Contains "Common Pitfalls" subsection
    - Each lesson references specific v1.2 implementation decisions
  </verify>
  <done>Lessons learned documented for future maintenance (ARCH-03)</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Read PATTERNS.md and verify all new sections exist
2. Confirm ASCII diagrams render correctly in markdown preview
3. Verify code examples are syntactically correct TypeScript
4. Check that lessons reference actual patterns from Phase 1/2 summaries
</verification>

<success_criteria>
- PATTERNS.md contains orchestrator deep dive with ASCII data flow diagram
- Critical callback wiring is documented in table format
- 4+ lessons learned are documented with problem/solution format
- All ARCH requirements (ARCH-01, ARCH-02, ARCH-03) are satisfied
- Documentation is practical and actionable for future developers
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish-docs/03-01-SUMMARY.md`
</output>
